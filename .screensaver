# Screensaver configuration
SCREENSAVER_TIMEOUT=10 # 600  # 10 minutes in seconds
SCREENSAVER_ENABLED=true

# Internal variables
SCREENSAVER_LAST_ACTIVITY=$(date +%s)
SCREENSAVER_ACTIVE=false
FOREGROUND_PROCESS_START_TIME=0

# Function to show true overlay
show_screensaver_overlay() {
    # Save cursor position and hide cursor
    printf '\033[s\033[?25l'
    
    # Move to a clear area (top of screen) and save that position too
    printf '\033[H'
    
    # Create inverted/colored overlay area
    printf '\033[44m\033[97m'  # Blue background, white text
    echo "    💤 SCREENSAVER - Where are you? Press Enter to continue...    "
    printf '\033[0m'  # Reset colors
    
    # Move back to original cursor position
    printf '\033[u'
    
    # Wait for any key press (not just Enter)
    read -s -k
}

# Alternative: GIF overlay
show_gif_overlay() {

    local gifs=(
        "https://tenor.com/view/hacker-hacker-man-hacking-hackers-hack-gif-23864910"
        "https://tenor.com/view/hacker-man-hacker-neon-ps4-glitched-gif-20054441"
        "https://tenor.com/view/pokemon-fire-red-leaf-green-remake-snorlax-gif-23083502"
        "https://tenor.com/view/lr-teq-vegeta-giant-ape-furious-last-resort-overwhelming-combat-final-bullet-attack-hyper-explosive-wave-gif-5882373243771434785"
    )

    # Save cursor and hide it
    printf '\033[s\033[?25l'
    
    # Save current screen content (alternative buffer)
    printf '\033[?1049h'
    
    # Clear screen and display GIF
    printf '\033[2J\033[H'

    # Get size of array and a random index
    local size=${#gifs}
    local index=$(( (RANDOM % size) + 1 ))
    local random_gif=${gifs[$index]}

    # Calculate smaller dimensions to prevent flicker
    local rows=$(( $(tput lines) - 4 ))  # Leave space for message
    local cols=$(( $(tput cols) - 4 ))   # Leave margins
        
    # Ensure minimum dimensions
    (( rows < 10 )) && rows=10
    (( cols < 20 )) && cols=20

    # Show instruction at bottom
    local lines=$(tput lines)
    printf '\033[%d;1H\033[44m\033[97m' $((lines - 1))
    echo " Press Ctrl+C to exit screensaver... "
    printf '\033[0m'

    # Move cursor to a safe position to run gif-for-cli in foreground
    printf '\033[2;1H'

    # Save terminal settings
    local original_stty
    original_stty=$(stty -g)

    # Configure terminal to ignore regular keypresses
    stty intr ^C
    stty -echo -icanon
    stty susp undef quit undef eof undef

    # Show random GIF from list
    gif-for-cli -m truecolor "$random_gif" --rows $rows --cols $cols -l 0
#    local gif_pid=$!

    # Restore terminal settings
    stty "$original_stty"

    # Wait for any key
#    read -s -k

    # Kill the gif process
#    kill $gif_pid 2>/dev/null
#    wait $gif_pid 2>/dev/null  # Clean up zombie process
    
    # Restore original screen content
    printf '\033[?1049l'
    
    # Restore cursor and show it
    printf '\033[u\033[?25h'
 
}

# Alternative: More visual overlay with border
show_fancy_overlay() {
    # Save cursor and hide it
    printf '\033[s\033[?25l'
    
    # Get terminal dimensions
    local lines=$(tput lines)
    local cols=$(tput cols)
    
    # Calculate center position
    local center_line=$((lines / 2 - 3))
    local center_col=$((cols / 2 - 20))
    
    # Save current screen content (alternative buffer)
    printf '\033[?1049h'
    
    # Clear and create overlay
    printf '\033[2J\033[H'
    
    # Semi-transparent dark background
    for ((i=1; i<=lines; i++)); do
        printf '\033[%d;1H\033[48;5;236m%*s\033[0m\n' $i $cols ""
    done
    
    # Create message box in center
    local box_start=$((center_line - 2))
    printf '\033[%d;%dH\033[48;5;240m\033[97m╔═══════════════════════════════════════╗\033[0m' $((box_start++)) $center_col
    printf '\033[%d;%dH\033[48;5;240m\033[97m║              💤  SCREENSAVER          ║\033[0m' $((box_start++)) $center_col
    printf '\033[%d;%dH\033[48;5;240m\033[97m║          Where are you?               ║\033[0m' $((box_start++)) $center_col
    printf '\033[%d;%dH\033[48;5;240m\033[97m║      Press any key to continue        ║\033[0m' $((box_start++)) $center_col
    printf '\033[%d;%dH\033[48;5;240m\033[97m╚═══════════════════════════════════════╝\033[0m' $((box_start++)) $center_col
    
    # Wait for any key
    read -s -k
    
    # Restore original screen content
    printf '\033[?1049l'
    
    # Restore cursor and show it
    printf '\033[u\033[?25h'
}

# Simple banner overlay (least intrusive)
show_banner_overlay() {
    printf '\033[s\033[?25l'  # Save cursor, hide it
    
    # Move to top and create a banner
    printf '\033[H\033[41m\033[97m'  # Red background, white text
    echo " SCREENSAVER ACTIVATED - Where are you? Press any key... "
    printf '\033[0m'  # Reset colors
    
    # Move back to original position
    printf '\033[u'
    
    # Wait for any key
    read -s -k
    
    # Clear the banner by overwriting with spaces
    printf '\033[s\033[H'
    printf '%*s' $(tput cols)  # Fill line with spaces
    printf '\033[u\033[?25h'   # Restore cursor and show it
}

# Function to update activity timestamp
update_activity() {
    SCREENSAVER_LAST_ACTIVITY=$(date +%s)
    if [[ $SCREENSAVER_ACTIVE == "true" ]]; then
        SCREENSAVER_ACTIVE=false
        # No need to restore content since we never cleared it
        zle && zle reset-prompt
    fi
}

# Function to check and trigger screensaver
check_screensaver() {
    if [[ $SCREENSAVER_ENABLED != "true" ]] || [[ $SCREENSAVER_ACTIVE == "true" ]]; then
        return
    fi

    local current_time=$(date +%s)
    local time_diff=$((current_time - SCREENSAVER_LAST_ACTIVITY))
    
    if (( time_diff >= SCREENSAVER_TIMEOUT )); then
        SCREENSAVER_ACTIVE=true
        show_gif_overlay  # Change this to test different styles
        update_activity
    fi
}

# Hook into ZSH
screensaver_preexec() {
    # Record when a foreground process starts
    FOREGROUND_PROCESS_START_TIME=$(date +%s)
}

screensaver_precmd() {
    # If a foreground process just finished, update activity with its end time
    if (( FOREGROUND_PROCESS_START_TIME > 0 )); then
        SCREENSAVER_LAST_ACTIVITY=$(date +%s)
        FOREGROUND_PROCESS_START_TIME=0
    fi
    
    check_screensaver
}

screensaver_postexec() {
    update_activity
}

autoload -Uz add-zsh-hook
add-zsh-hook preexec screensaver_preexec
add-zsh-hook precmd screensaver_precmd

# Track terminal activity
zle-keymap-select() {
    update_activity
}

zle-line-init() {
    update_activity
}

zle -N zle-keymap-select
zle -N zle-line-init

# Control functions
screensaver_disable() { SCREENSAVER_ENABLED=false; echo "Screensaver disabled" }
screensaver_enable() { SCREENSAVER_ENABLED=true; update_activity; echo "Screensaver enabled" }
screensaver_test() { SCREENSAVER_LAST_ACTIVITY=0; echo "Testing screensaver..." }

alias ss-off='screensaver_disable'
alias ss-on='screensaver_enable'
alias ss-test='screensaver_test'
